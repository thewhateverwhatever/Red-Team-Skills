# Understanding NFS (Network File System)

## What Is NFS?

NFS, short for **Network File System**, is a protocol that allows one system to share files and directories with other systems over a network. With NFS, users and applications can interact with remote files almost as if they were stored locally. This works by mounting an entire filesystem—or a specific portion of it—from a remote server onto a client machine. Once mounted, the client can access the shared files with whatever permissions have been assigned on the server side.

---

## How Does NFS Work?

> We don’t need deep protocol-level knowledge to use or exploit NFS effectively—but if you're interested in the underlying mechanics, this resource offers an excellent explanation:  
> https://docs.oracle.com/cd/E19683-01/816-4882/6mb2ipq7l/index.html

### 1. Mounting a Remote Directory
A client begins by requesting to mount a directory from the NFS server, just like mounting a local storage device.  
This request is handled by the **mount service**, which uses **RPC (Remote Procedure Call)** to communicate with the server’s mount daemon.

### 2. Server Validation
The server checks whether the requesting user has permission to mount the directory.  
If allowed, the server returns a **file handle**, a unique identifier for each file or directory hosted on the server.

### 3. Accessing Files
When the client attempts to access a file through NFS:

An RPC request is sent to **NFSD** (the NFS daemon) on the server.  
This request includes:

- The file handle  
- The file name  
- The user’s UID  
- The user’s GID  

The server evaluates these values to determine what the user is allowed to do—such as reading or writing the file.

This permission-checking logic is what ultimately enforces user access rights.

---

## What Systems Use NFS?

Because NFS is a cross-platform protocol, it enables seamless file sharing between:

- Linux  
- macOS  
- UNIX  
- Windows (with NFS services installed)

A Windows Server machine can function as an NFS server for Linux/UNIX/macOS clients, and similarly, Windows can access shares hosted on a non-Windows NFS server.


In short, NFS acts as a universal bridge for file sharing across mixed operating-system environments.

---

# Enumeration

## Tools Used
- nfs-common
- nmap

## Stuff Found
1. Nmap Scan:

<img width="1004" height="256" alt="image" src="https://github.com/user-attachments/assets/59d5817a-895a-4a24-8548-29c81655dcf3" />

2. Visible Shares:

<img width="1004" height="64" alt="image" src="https://github.com/user-attachments/assets/861e6cad-fe17-45d6-a758-c48f70538b9a" />


4. Directories in the share:

<img width="1004" height="24" alt="image" src="https://github.com/user-attachments/assets/2068c02e-d6fb-411f-b405-efa6f6c15d83" />

<img width="1004" height="38" alt="image" src="https://github.com/user-attachments/assets/4111273c-e053-4e18-bc0c-0998931f4b45" />


5. Keys in the ssh directory: ** **

<img width="1004" height="38" alt="image" src="https://github.com/user-attachments/assets/6790f524-7874-47b7-911f-3caf01c3e6e7" />


6. Logged into the machine with the private ssh key:

<img width="1004" height="599" alt="image" src="https://github.com/user-attachments/assets/822cc6ca-d87d-49a8-bd8e-5ad69b056a6e" />


# Exploiting NFS


If you gain a low-privilege shell on a machine and discover an **NFS share**, you may be able to escalate to **root**, depending on how the share is configured. One of the most important settings to check is something called **root_squash**.

---

## What Is `root_squash`?

When a client connects to an NFS share, the server needs to decide how to handle a user who appears as **root** on the remote system.

- **With `root_squash` enabled (default)**  
  The server downgrades remote root to a harmless user called **`nfsnobody`**, which has almost no privileges.  
  This prevents remote users from acting as root on the server's filesystem.

- **With `root_squash` disabled (`no_root_squash`)**  
  Remote users KEEP their root privileges on the mounted share.

This is extremely dangerous.  
If remote root is allowed, an attacker can **upload files with any permissions they want — including SUID binaries owned by root**.

---

## What Is the SUID Bit?

The **SUID bit** (“Set User ID”) is a Linux permission that says:

> “When this file runs, execute it with the permissions of the file’s owner.”

So if a file is:
- owned by **root**, and  
- has the **SUID bit** set  

Then **any user who runs it executes commands as root**.

This makes SUID binaries a powerful privilege escalation path.

---

## How NFS Misconfiguration Leads to Root

If the NFS export is configured with `no_root_squash`, anyone who mounts it can:

1. Upload a file (e.g., `/bin/bash`)
2. Set the owner to **root**
3. Add the SUID bit
4. Execute it later to obtain a **root shell**

This works because the NFS server incorrectly trusts the remote system’s root user.

---



Download the bash executable:

<img width="1445" height="306" alt="image" src="https://github.com/user-attachments/assets/76212e86-ff0a-4b3c-9cdb-62b63123fd6e" />

Copy the file to the mount point and then run the following commands:
```
sudo chown root bash
```
```
sudo chmod +s bash
sudo chmod +x bash
```

Lastly ssh into the machine with the ssh private key we found earlier and run the following commands:

```
./bash -p
```

Here is the root access:

<img width="1445" height="108" alt="image" src="https://github.com/user-attachments/assets/4f3d9453-6c43-40ac-8326-accf23c0aeb1" />






